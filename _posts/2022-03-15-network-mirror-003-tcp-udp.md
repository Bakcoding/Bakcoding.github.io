---
title:  "TCP/UDP"
excerpt: "Network, Mirror"

categories:
  - Mirror
tags:
  - [Network, Mirror]

toc: true
toc_sticky: true
 
date: 2022-03-15
last_modified_at: 2022-03-15
---  

***

<br>

## TCP & UDP

둘 다 인터넷을 통해 정보를 보내기 위해 사용되는 프로토콜이다. 

**차이점**

* TCP에는 신뢰성이 내장되어 있어 더 긴 지연 시간을 유지하면서 A에서 B까지 데이터를 정확하게 전달할 수 있다.

* UDP는 데이터 전송 시 지연 시간이 짧지만 원시 프로토콜은 본질적으로 신뢰할 수 없으며 데이터가 A에서 B로 올바르게 전송되지 않는다.

<br>

### TCP

transmission control protocol

전송 제어 프로토콜

인터넷에서 가장 인기 있는 프로토콜로 HTTP, SSH, FTP 및 더 많은 응용프로그램에서 사용된다.
핵심 기능은 프로그래머가 A에서 B로 데이터를 정확하게 보낼 수 있도록 보장하기 때문에 프로그래머들이 프로토콜로 쉽게 작업할 수 있게 한다.

하지만 오작동하거나 심각한 난기류가 발생하여 지연 시간이 길어질 수 있다. 

게임 환경을 기준으로 TCP는 지연 시간 보다 게임 데이터가 중요한 게임에 유리하다.

#### 주요 특징

##### Reliable(신뢰)
  
* 응용 프로그램은 패킷 누락에 대해 걱정할 필요가 없다. 

* 패킷이 손실되면 TCP에서 다시 보내며 모든 데이터가 성공적으로

* 전송되었거나 오류가 발생하면 연결이 종료된다.

<br>

##### Sequenced(병렬) 

* TCP는 모든 메시지가 전송된 순서대로 도착하도록 보장한다.

* 만약 a를 보내고 b를 보내면 반대편도 a와 b를 받게 된다.

<br>

##### Connection oriented(연결 지향)

* TCP는 연결의 컨셉을 가지고 있다. 

* 클라이언트 또는 서버가 연결을 닫기로 결정할 때 까지 연결은 열린 상태로 유지된다. 
연결이 종료되면 클라이언트와 서버 모두 알림을 받는다.

<br>

##### Congestion control(폭주 제어)

* 서버가 과부하 상태인 경우 TCP는 혼잡 붕괴를 방지하기 위해 데이터를 조절한다.

<br>

### UDP

user datagram protocol

사용자 데이터그램 프로토콜

빠른 속도의 액션 게임이나 VoIP(voice over IP)와 같은 실시간 응용 프로그램에 사용되며 짧은 대기 시간이 신뢰성보다 중요하다.

게임 환경에서는 UDP의 raw power를 활용하여 데이터가 전송되는 방식을 보다 효과적으로 제어할 수 있어 중요하지 않은 데이터를 더 빠르게 전송할 수 있다.

이는 서버와 클라이언트간의 지연 시간이 중요하고 몇 개의 패킷이 손실되면 게임이 복구되는 빠른 속도의 게임에 UDP를 더 좋게 만든다.

<br>

#### 주요 특징

##### Low Latency 

* UDP는 원격 측에서 패킷을 승인할 때까지 기다릴 필요가 없으므로 빠르다.

* 스캐터샷, 새로운 데이터 패킷을 차례로 계속 전송할 수 있다. 데이터를 얻을 것이라는 보장 없이 클라이언트에게 데이터를 보낸다.

<br>

##### Channel Support

* 채널은 다양한 전송 유형을 허용한다. 구현에 따라 목적지까지 도달해야 하는 중요 데이터에는 한 채널을 신뢰성 없이 보내고 잊어버리는 데이터 전송에는 다른 채널을 사용할 수 있다.

<br>

##### Different packet types

* UDP 프로토콜 위의 구현에 따라 일부 전송은 다른 패킷 전송 방식을 제공한다.

  구현에 따라 Reliable Ordered, Reliable Unordered, Unreliable ... 

* Reliable UDP 전송은 구현에 따라 달라지지만 보통은 TCP의 신뢰성 시스템을 본떠 모델링된다.

<br>

#### Transports using the UDP Protocol

##### Ignorance

ENet-CSharp의 커스텀 포크를 통해 네이티브 ENet C 네트워킹 라이브러리를 이용하는 Reliable UDP 전송 계층이다.

64비트 데스크톱 운영 체제와 모바일 모두에 대해 신뢰할 수 있으면서 신뢰할 수 없는 sequenced UDP전송을 제공하며 또한 한 번에 최대 255개의 채널과 4096개의 클라이언트를 연결할 수 있다.

ENet은 견고하고 안정적인 신뢰할 수 있는 UDP C++ 네트워크 라이브러리이다.

Ignorance는 공백을 메우며 Mirror를 위한 견고한 성능인 RUDP 전송을 제공한다.

<a href="https://github.com/SoftwareGuy/ignorance">Ignorance</a>

<br>

**TCP를 통해 신뢰할 수 있는 UDP를 사용해야하는 경우**  

* VoIP와 같은 안정성보다 속도가 빠른 실시간 통신이 필요한 경우

* 채널이 필요할 때 

* 사용자 지정 채널 전송 유형이 필요한 경우

* 데이터 호스가 필요한 게임인 경우, 1인칭 슈팅 게임, 레이싱 게임 등

<br>

**TCP를 통해 신뢰할 수 있는 UDP를 사용하지 않는 경우**  

* 임무 수행에 필수적인 사항이 있는 경우

  A 및 B에서 예외없이 데이터를 가져와야할 때

* 완전 신뢰할 수 있는 네트워크 프로토콜이 필요할 때

* 마인크래프트 처럼 모든 사람의 싱크가 지켜질 필요가 있을 때


<br>

**추가적으로**

UDP는 shattershot 데이터 전송 프로토콜로 가장 잘 설명된다. 

* Shatershot 

  목적지에 패킷을 뿌리고 최상의 결과가 나오길 기도하는 것을 의미한다.

원격 대상은 이러한 패킷을 수신하거나 수신하지 않을 수 있으며 순서대로 수신되지 않을 수도 있다.

예를 들어서 다음과 같은 스트림이 있다.

1 1 2 3 4 5 6 7

패킷이 고장나면 다른 쪽 끝에서 다음과 같이 끝날 수 있다. ( . 은 패킷이 누락되었음을 의미)

1 7 6 1 3 2 4 5 
2 7 6 . . 4 . 1
3 . . . . 1 2 3
4 1 2 3 5 4 6 7 

만약 이런 패킷이 손실된 상황이 플레이어의 상태 업데이트가 포함되어 있다고 가정할 한다면

플레이어가 69만큼의 피해를 봤지만 여전히 클라이언트는 예전 값인 72의 체력을 가지고 있을 때 

신뢰할 수 있는 UDP가 없으면 동기화가 매우 빠르게 중단될 수 있다. 이 플레이어가 동기화 되지 않으면 모든 것이 이상하게 동작하기 시작하며 게임은 끝이날 것이다.

<br>

**Sequencing과 Reliable Delivery**

sequencing은 기본적으로 패킷에 태그를 지정하여 패킷이 몇 번인지 알 수 있도록 한다.

따라서 패킷 100, 101, 102 를 원격 대상으로 전송하는 경우 다른 쪽 끝은 101, 100, 102처럼 전송할 때 순서와 다르게 해당 순서로 패킷을 재구성한다.

여기서 패킷이 누락되면 건너 뛰지만 네트워크 라이브러리에서 누락 사실을 확인하고 보상한다.

reliable mode는 패킷 수신이 손실되었다고 주장하기 전에 원격 패킷 수신을 승인할 때 까지 기다리는 동안 ENet에게 이 신호를 전송하도록 지시한다.

ENet은 원격으로부터 회신을 받지 못하면 패킷들을 손실로 분류하지만 연결이 끊기거나 대기 시간이 긴 상황을 보상하기 위해 패킷을 재전송한다.

제때 승인되지 않을 경우 TCP의 재전송 중 일부를 emulate하려고 한다. 하지만 UDP는 TCP 프로토콜이 가진 오버헤드를 모두 가지고 있지 않기 때문에 패킷 오버헤드를 일부 추가한다.

<br>

***

Ignorance는 기본적으로 신뢰할 수 있는 모드와 신뢰할 수 없는 모드 모두에서 발생한다. 개발자가 각기 다른 부하에 적합할 수 있으므로 테스트할 수 있는 다른 채널 모드가 있지만 일반인은 걱정할 필요가 없다.

<br>


##### KCP

KCP는 TCP보다 10 - 20% 더 많은 대역폭을 낭비하지만 평균 대기 시간을 30 - 40% 줄이고 최대 지연 시간을 3배 줄이는 전송효과를 얻을 수 있는 빠르고 신뢰할 수 있는 프로토콜이다.

C 전송 속도만큼 빠르면서 100% C#이기 때문에 유지관리가 쉽다는 장점이 있다.

* 100% C#으로 작성되었다.

* WebGL을 제외한 모든 플랫폼에서 적용가능하다.

* 매우 빠르며 간단하다.

* 할당이 거의 없다.

<a href="https://github.com/skywind3000/kcp/blob/master/README.en.md">KCP</a>

<br>

##### LiteNetLib Transport

Mirror를 위한 전송을 기반으로 한다.

<a href="https://github.com/MirrorNetworking/LiteNetLibTransport/releases">LiteNetLib</a>

**특징**  

* UDP

* Network Discovery와 UPnP가 내장되어있다.

* 완전 관리 코드

* 작은 CPU, RAM 사용량

* 작은 오버헤드 패킷 사이즈(unreliable 1byte, reliable 3byte)

* 다른 전송 방식

* Reliable with order / Reliable without order

* 중복 방지 기능을 사용할 경우 성능이 떨어진다.

* order와 reliability이 없는 간단한 UDP 패킷

* 작은 패킷 자동 병합

* 신뢰할 수 있는 패킷의 자동 조각화

* MTU 자동 감지

* NTP(Network time protocol) 시간 요청

* 패킷 손실 및 지연 시간 시뮬레이션

* IPv6 지원

* 멀티캐스팅


<br>

### 정리

Mirror는 전송에 독립적이며 네트워크 매니저 게임 오브젝트에 추가하기만 하면 된다.

기본적으로 KCP 전송이 함께 제공된다. 따라서 개발자에게 가장 적합한 수단을 선택하여 사용한다.

최종 결정을 내리기 전에 게임의 네트워킹 프로파일링과 실제 숫자를 수집하는 것이 좋다.
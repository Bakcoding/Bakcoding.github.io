---
title:  "배칭"
excerpt: "unity3d, engine, batching"

categories:
  - Unity3D
tags:
  - [unity3d, engine, batching]

toc: true
toc_sticky: true
 
date: 2022-03-01
last_modified_at: 2022-03-01
---  

***

<br>

### 배칭

batching 

동일한 머티리얼을 공유하는 복수의 드로우 콜을 하나로 묶어서 드로우 콜하는 기법이다. 

유니티에서 배칭의 수는 = draw call + setpass calls 라고 볼 수 있다. 

<br>

### 드로우 콜

draw call

![draw-call-flow](/assets/images/20220301_Posting/draw-call-flow.png)

<br>

CPU에서 처리한 연산결과를 GPU에 보내 오브젝트를 그려라 요청하는 것이다.  

드로우 콜 간에는 머티리얼의 전환등의 스테이트 변경으로 인해 그래픽 드라이버에서 리소스가 많이 사용되는 확인 및 이동 단계를 수행해야 하기 때문에 종종 리소스가 많이 사용되고 그래픽스 API가 모든 드로우 콜에 중요 작업을 수행함에 따라서 CPU 성능이 많이 사용될 수 있다.  

**드로우 콜 발생**  

* 하나의 오브젝트에 메시가 여러 개인 경우

* 하나의 오브젝트에 여러개의 머티리얼이 있는 경우

* 하나의 셰이더에 멀티 패스가 정의된 경우

<br>

### 셋패스 콜

setpass call

머티리얼의 설정(shader, texture, blending 등)에 따라서 카운트된다.  

**셋패스 콜 발생**

* 셰이더로 인한 렌더링 패스 횟수

* 메시, 텍스쳐, 셰이더, 라이트 등의 정보

* 하나의 셰이더 내에서 multi-pass를 통해 2번 이상의 렌더링을 거치면 사용하면 2번의 드로우 콜이 발생한다. 

<br>

### 배칭 종류

유니티의 배칭 방식은 두 가지가 있다. 

Edit > ProjectSetting > Player > OtherSettings 

<br>

#### 정적 배칭

static batching

움직이지 않고 동일 머티리얼을 공유하는 모든 크기의 오브젝트 대상으로 적용되어 드로우 콜을 줄인다. 

정보를 메모리에 올리기 때문에 CPU 부담을 메모리로 옮긴다고 볼 수 있다.  

따라서 일반적으로는 동적 배칭보다는 효과가 좋지만 과도하게 많은 오브젝트를 사용하게 되면 메모리 부담이 높아지기 때문에 역효과가 발생할 수 있다.  

<br>

#### 동적 배칭

dynamic batching

게임 오브젝트의 정적으로 체크되지 않은 오브젝트 대상으로 유니티가 처리한다. 

조건이 까다롭기 때문에 배칭없이 처리되는 것보다 효율이 안좋은 경우도 발생할 수 있다. 

<br>

##### 메시

같은 머티리얼을 공유하면서 다른 조건을 충족하는 움직이는 게임 오브젝트를 동일 드로우 콜 안에 자동으로 배칭한다. 

정점이 너무 많은 메시의 경우 정점을 수집하면서 오버헤드가 드로우 콜 보다 높아져 대상에서 제외된다.  

**조건**

동적 게임 오브젝트 배칭은 리소스 사용량이 정점마다 일정하다. 

따라서 900개 미만의 정점과 속성이 300개 미만인 정점이 포함된 메시에서만 적용된다.

* 트랜스폼에 미러링이 포함된 게임 오브젝트는 제외된다.

* 머티리얼이 다르면 배칭되지 않는다. (새도우 캐스터 렌더링 제외)

* 동적 라이트맵이 적용된 게임 오브젝트는 배칭할 라이트맵 위치와 정확이 같은 위치를 가르켜야한다. 

* 멀티패스 셰이더는 배칭을 중단시킨다.

  거의 대부분의 유니티 셰이더는 렌더링 시 몇 가지의 광원을 지원하여 추가 패스를 대신 수행하기 때문에 추가 라이트에 대한 드로우 콜은 배칭되지 않는다. 

  광원 프리패스(legacy deferred) 렌더링 경로는 게임 오브젝트를 두 번 드로우 하기 때문에 동적 배칭이 불가능하다.

<br>

##### 파티클 시스템, 라인 렌더러, 트레일 렌더러

동적으로 생성하는 지오메트리가 포함된 컴포넌트의 경우 동적 배칭은 메시에 대한것과 다르게 동작한다.  

* 호환 가능한 렌더러 타입 각각에 대해 모든 배칭 가능한 콘텐츠를 하나의 커다란 정점 버퍼로 빌드한다.

* 렌더러는 배치에 대한 머티리얼 상태를 설정한다.

* 정점 버퍼를 그래픽스 기기에 바인드한다.

* 배치의 렌더러 각각에 대해 오프셋을 정점 버퍼로 업데이트한 다음 새로운 드로우 콜을 제출한다.

그래픽스 기기 호출의 성능 부하를 측정하는 경우 컴포넌트 렌더링의 가장 느린 부분이 머티리얼 상태로 결정된다.  

다양한 오프셋의 드로우 콜을 공유 정점 버퍼로 제출하면 비교적 속도가 매우 빠르며 유니티가 드로우 콜을 제출하는 방법과 가장 유사하다.

<br>

### 효과적인 배칭

같은 머티리얼을 공유하는 게임 오브젝트만 함께 배칭이 된다.

배칭의 효과를 높이려면 가능한 많은 게임 오브젝트 간에 머티리얼을 공유하도록 만들어야한다.  

<br>

#### 텍스쳐

텍스처만 다른 동일한 머티리얼이 2개 있을 때 더 큰 텍스처안에 여러개의 텍스쳐들을 담아서 하나로 합칠 수 있다. 

이를 텍스처 아틀라싱이라고 부르기도하며 이 결과물을 아틀라스라고 한다.  

텍스처가 같은 아틀라스 안에 있다면 머티리얼을 하나로 사용할 수 있게된다.

<br>

#### 스크립트

스크립트를 통해 공유된 머티리얼 프로퍼티에 접근하는 경우 (Renderer.shareMaterial) 

머티리얼의 복사본이 생성되기 때문에 공유된 상태로 머티리얼을 유지해야한다는 점을 주의한다. 

<br>

#### 새도우 캐스터

새도우 캐스터는 머티리얼이 다른 경우에도 렌더링 중에 배칭이 가능하다. 새도우 패스에서 필요한 머티리얼의 값이 동일한 경우 다른 머티리얼을 동적 배칭으로 사용할 수 있다. 

다양한 텍스처를 사용중인 머티리얼이라도 새도우 캐스터는 텍스처 렌더링이 중요하지 않으므로 함께 배칭이 가능하다.

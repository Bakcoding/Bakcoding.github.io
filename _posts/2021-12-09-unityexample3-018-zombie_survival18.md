---
title:  "[레트로의 유니티] 좀비서바이벌18 - 네트워크"
excerpt: "unity3d, retro, example, zombie, multiplayer, network"

categories:
  - UnityExample
tags:
  - [unity3d, retro, example, zombie, multiplayer, network]

toc: true
toc_sticky: true
 
date: 2021-12-09 
last_modified_at: 2023-06-05
---  

***  

### 네트워크  

네트워크상에서 각 클라이언트의 게임 월드는 평행우주처럼 동작한다.  

클라이언트는 서버에 접속하여 서비스를 제공받는 단말기, 프로그램, 사용자를 뜻한다.  

![network](/assets/images/posting/20211209/network.png)


위 이미지에서 게임 월드  속의 A, B, C, D는 플레이어 캐릭터로 동작하는 게임 오브젝트이다. 

이렇게 각자의 클라이언트에 4명의 플레이어 캐릭터가 존재하므로 4인 멀티플레이어 게임에서 네트워크상에 존재하는 총 플레이어 캐릭터는 16명이다.  

A의 클라이언트 상에 A는 B클라이언트의 A와는 서로 다른 게임 오브젝트로 실제로는 아무 상관이 없는 별도의 오브젝트로 존재하게 된다.  

다만 네트워크상에서는 관리자가 이 둘에 동일한 식별자를 부여하여 연결된 동안에는 서로를 동일한 상태로 동기화 할 수 있게 된다.  

<br>

#### 로컬과 리모트

로컬은 물리적으로 사용자의 위치에 존재하는 단말기나 프로그램, 오브젝트를 표현하는 단어이다.  

리모트는 반대로 원격 접속을 통해 접근할 수 있는 단말기나 프로그램 오브젝트를 표현하는 단어이다.  

네트워크 게임에서 씬에 존재하는 게임 오브젝트는 로컬 오브젝트와 리모트 오브젝트로 구분할 수 있다. 로컬과 리모트를 나누는 기준 중 하나는 해당 게임 오브젝트의 주도권을 가진 사람이다. 

특히 게임 오브젝트가 플레이어로 동작하는 게임 오브젝트를 로컬 플레이어 캐릭터, 그렇지 않으면 리모트 플레이어 캐릭터로 구분한다.  

즉 A클라이언트에서 A는 로컬 플레이어 캐릭터 나머지 B, C, D는 리모트 플레이어 캐릭터이다.  

<br>

#### 동기화  

플레이어 A가 자신의 로컬 플레이어 캐릭터를 움직일 때 다른 플레이어 B, C, D의 게임 월드에서도 리모트 플레이어 캐릭터 A가 움직여야한다.  

하지만 실제로는 서로 다른 오브젝트이기 때문에 동일하게 움직이기 위해서는 A의 분신이라 볼 수 있는 다른 클라이언트 상의 A에 신호를 전달해야 한다.  

매번 정보가 갱신될 때마다 신호를 보내면서 반영을 해주면 동일하게 A들이 동작하는 모습으로 동기화할 수 있다.  

그렇기 때문에 동기화 간격이 길어지게 되거나 인터넷 속도가 느려지면 A간의 모습이 조금씩 차이가 날 수 있고 연결이 끊기게 되면 서로 완전히 독립된 오브젝트가 되어버린다. 

<br>

#### 로컬 권한 검사  

로컬과 리모트 플레이어 캐릭터 모두 사용자의 입력을 받을 수 있다. 따라서 조작을 로컬 플레이어 캐릭터에만 반영 시킬 수 있도록 오브젝트가 로컬 권한을 가지고 있는지 검사가 필요하다. 

조건문을 통해서 로컬과 리모트 오브젝트를 구분해서 리모트라면 사용자의 입력을 무시하도록한다.  

```cs
// A, B, C, D
void Update() {
  if (!local) {
    return;
  }
  
  // 사용자 입력 감지
  // 움직임 적용
}
```

<br>

### 게임 서버 종류  

기본적으로 네트워크 기반 게임은 대기 중인 서버에 클라이언트들이 참가하는 서버-클라이언트 방식으로 동작한다.  

서버는 클라이언트들이 참가할 수 있는 네트워크 공간을 마련하는 컴퓨터이며 호스트라고 하며, 클라이언트는 서버에 참가하여 게임을 플레이하는 컴퓨터이다.  

서버는 단순히 고정된 네트워크 공간을 마련하는 것뿐만 아니라 게임 속 상호작용 연산도 담당한다.  

<br>

**서버-클라이언트 종류**  

* 전용 서버 (Dedicated Server)

* 리슨 서버 (Listen Server)

* P2P (Peer-to-Peer)

<br>

#### 전용 서버

서버의 모든 자원이 온전히 네트워크 서비스를 유지하는데 사용되며, 서버가 플레이어로서 게임에 직접 참가하지 않는 형태이다.  

![dedicated](/assets/images/posting/20211209/dedicated.png)  

전용 서버 방식에는 언제든지 참가 가능하며, 고정된 고성능 서버를 제공하기 때문에 서버에 접속한 클라이언트는 쾌적한 환경에서 게임을 즐길 수 있지만 다른 방식에 비해 고정비용이 많이 발생한다.  

<br>

#### 리슨 서버 

전용 서버가 없는 대신 플레이어 클라이언트 중 하나가 서버 역할을 맡는다. 리슨 서버가 직접 게임에 참가하기 때문에 'Play as Host' 라고 부르기도 한다. 

서버 역할을 맡은 클라이언트를 방장, 호스트, 마스터 클라이언트 등으로 부른다.  

![listen](/assets/images/posting/20211209/listen.png)  

전용 서버 방식에 비해 서비스 유지비용이 적다. 또한 물리적으로 매우 가까운 위치에 있는 플레이어들 간에는 너트워크 반응 속도가 전용 서버보다 빠를 수 있다.  

호스트 플레이어의 컴퓨터 성능에 따라 네트워크 품질이 크게 달리지고 호스트가 게임을 종료할 경우 진행 중인 게임을 일시 정지하고 남은 클라이언트 중에서 새로운 호스트를 선정하는 절차 (Host Migration)이 필요하다.

<br>

#### P2P

게임에 참가한 클라이언트들 모두가 호스트 역할을 겸한다. 특정 단일 호스트에 참가하는 방식이 아닌 서로 직접 연결된 형태이다.  

일반적으로 네트워크 게임에서 호스트는 클라이언트에 비해 연산 부담이 크다. 호스트는 네트워크 룸을 유지하는데 필요한 연산과 게임 속 중요한 연산 대부분을 수행한다.  

반면 P2P 방식에서는 연산 대부분을 독점하는 특정 호스트가 없어 클라이언트 각자 자신의 월드에서 자신의 담당 연산을 실행하고 다른 클라이언트에 결과를 전파한다.

![p2p](/assets/images/posting/20211209/p2p.png)  

전용 서버가 없다는 점에서 리슨 서버 바식과 유사하지만, 호스트가 게임 도중 접속을 종료했을 때 호스트를 교체하는 과정이 불필요하다. 서버 유지비용 또한 발생하지 않으며 클라이언트끼리 직접 연결되기 때문에 클라이언트 수가 적은 경우에 한해서 다른 방법보다 네트워크 반응 속도가 빠르며 또한 개발자 입장에서 P2P를 사용하면 프로그램의 처리 흐름을 직관적으로 설계할 수 있다.  

하지만 각각의 클라이언트가 자신을 제외한 다른 모든 클라이언트와 직접 연결되어 있어야하므로 연결수가 늘어날수록 클라이언트의 부담이 늘어나며 어느 시점부터는 호스트-클라이언트 방식의 호스트보다 더 많은 연산 부담을 가지게 된다. 따라서 참가자가 증가할수록 반응 속도가 눈에 띄게 느려지기 때문에 이 방식은 통상 16명을 참가자 상한선으로 여긴다. 

무엇보다도 수치 변조에 제일 취약하기 때문에 이 수치를 조작하여 다른 클라이언트에 전파할 위험이 크다.  

